pipeline {
    agent any

    // 전역 변수 설정
    environment {
        IMAGE_NAME_FE = "lingotown_front_image"
        CONTAINER_NAME_FE = "LingoTown_Front_Dev"
        APPLICATION_ENV_PATH = "/usr/react"
        PROJECT_DIR_FE = "Front"
    }

    stages {
        // 설정파일 참조
        stage("Copy Setting File") {
            steps {
                script {
                    try {
                        sh "cp ${env.APPLICATION_ENV_PATH}/.env ${env.PROJECT_DIR_FE}"
                    } catch (Exception e) {
                        // 설정 파일 복사 중 오류가 발생하면, 파이프라인 실행을 중단합니다.
                        echo "Failed to copy setting files, stopping the pipeline: ${e.getMessage()}"
                        error "Stopping the pipeline because the setting file copying stage failed."
                    }
                }
            }
        }

        // 컨테이너 클리닝
        stage("Docker Container Cleaning") {
            steps{
                sh "docker ps -q -f name=${env.CONTAINER_NAME_FE} | xargs --no-run-if-empty docker container stop"    
                sh "docker container ls -a -q -f name=${env.CONTAINER_NAME_FE} | xargs --no-run-if-empty docker rm"
            }
        }
        
        // 도커 이미지 빌드
        stage("Docker Image Build") {
            steps {
                // script {  // 'script' 블록 추가
                    // try {
                        dir("${env.PROJECT_DIR_FE}") {
                            sh "docker build --no-cache -t ${env.IMAGE_NAME_FE}:${BUILD_NUMBER} ."
                        }
                    // } catch (Exception e) {
                    //     // 빌드를 중지하고 오류 상태로 설정합니다.
                    //     echo "Docker build failed: ${e.getMessage()}"
                    //     error "Stopping build due to errors"
                    // }
                // }
            }
        }

        // 컨테이너 실행
        stage("Docker Container Run") {
            steps {
                script {
                    // 최신 빌드 이미지를 사용하여 컨테이너 실행 (Rollback Stage와 구분)
                    sh "docker run -d -p 3001:3000 --name ${env.CONTAINER_NAME_FE} ${env.IMAGE_NAME_FE}:${BUILD_NUMBER}"
                }
            }
        }
    }

    post {
        always {
            // 모든 경우에 실행되는 후처리 작업
            echo 'This will always run'
        }
        success {
            // 빌드가 성공적으로 완료된 경우에만 실행
            script {
                // 현재 빌드의 태그 정보를 파일로 저장합니다.
                def tagName = "${env.IMAGE_NAME_FE}:${env.BUILD_NUMBER}"
                writeFile file: 'successful_tag.txt', text: tagName
                archiveArtifacts artifacts: 'successful_tag.txt'  // 이 파일을 Jenkins artifact로 보관합니다.

                // 최근 성공한 이미지 태그 목록을 유지하기 위한 로직
                def recentSuccessfulTags = []
                def maxImagesToKeep = 5  // 유지할 이미지 수

                // 이전 빌드에서 아티팩트를 검색합니다.
                def currentBuildNumber = env.BUILD_NUMBER.toInteger()
                for (int i = 1; i <= maxImagesToKeep; i++) {
                    def previousBuildNumber = currentBuildNumber - i
                    def job = Jenkins.instance.getItemByFullName(env.JOB_NAME)

                    // 이전 빌드가 존재하는지 확인합니다.
                    def previousBuild = job.getBuildByNumber(previousBuildNumber)
                    if (previousBuild != null && previousBuild.result == Result.SUCCESS) {
                        def artifact = previousBuild.artifacts.find { it.fileName == 'successful_tag.txt' }
                        if (artifact != null) {
                            def tagInfo = artifact.file.text.trim()
                            recentSuccessfulTags.add(tagInfo)
                        }
                    }
                }

                // 전체 이미지 리스트를 가져옵니다.
                def allImages = sh(script: "docker images ${env.IMAGE_NAME_FE} --format '{{.Repository}}:{{.Tag}}' ", returnStdout: true).trim().split('\n')

                // 유지할 이미지 목록에서 제외된 이미지들을 삭제합니다.
                for (image in allImages) {
                    if (!recentSuccessfulTags.contains(image)) {
                        sh "docker rmi ${image} || true"  // 삭제 중 오류가 발생해도 계속 진행합니다.
                    }
                }
            }
        }
        failure {
            // 빌드가 실패한 경우 롤백 메커니즘 실행
            script {
                // 현재 빌드가 실패한 경우 이전 성공한 빌드에서 아티팩트를 가져오기
                if (currentBuild.currentResult == 'FAILURE') {
                    echo 'Starting Rollback Process...'

                    // 이전 성공한 빌드 번호 가져오기
                    def lastSuccessfulBuildNumber = currentBuild.getPreviousSuccessfulBuild()?.number

                    if (lastSuccessfulBuildNumber != null) {
                        // "Copy Artifact" 플러그인 기능 사용
                        step([
                            $class: 'CopyArtifact',
                            projectName: "${env.JOB_NAME}", // 현재 프로젝트 이름 사용
                            filter: 'successful_tag.txt', // 가져올 파일 지정
                            target: '', // 현재 작업공간으로 파일 복사
                            fingerprintArtifacts: true, // 아티팩트 지문 생성 옵션
                            selector: specific("${lastSuccessfulBuildNumber}") // 특정 빌드 번호에서 아티팩트 선택
                        ])

                        // 파일 읽기 및 태그 정보 추출
                        def tagInfo = readFile('successful_tag.txt').trim()
                        echo "Rolling back to previous stable build: ${tagInfo}..."

                        // 이전 성공한 이미지 태그로 롤백 프로세스 수행
                        sh "docker run -d -p 3001:3000 --name ${env.CONTAINER_NAME_FE}_rollback ${tagInfo}"
                    } else {
                        echo "No successful build to rollback to!"
                    }
                }
            }
        }
    }
}