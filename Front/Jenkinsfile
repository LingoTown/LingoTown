pipeline {
    agent any

    // 전역 변수 설정
    environment {
        IMAGE_NAME_FE = "lingotown_front_image"
        CONTAINER_NAME_FE = "LingoTown_Front_Dev"
        APPLICATION_ENV_PATH = "/usr/react"
        PROJECT_DIR_FE = "Front"
    }

    stages {
        // 설정파일 참조
        stage("Copy Setting File") {
            steps {
                script {
                    try {
                        sh "cp ${env.APPLICATION_ENV_PATH}/.env ${env.PROJECT_DIR_FE}"
                    } catch (Exception e) {
                        // 설정 파일 복사 중 오류가 발생하면, 파이프라인 실행을 중단합니다.
                        echo "Failed to copy setting files, stopping the pipeline: ${e.getMessage()}"
                        error "Stopping the pipeline because the setting file copying stage failed."
                    }
                }
            }
        }

        // 컨테이너 클리닝
        stage("Docker Container Cleaning") {
            steps{
                sh "docker ps -q -f name=${env.CONTAINER_NAME_FE} | xargs --no-run-if-empty docker container stop"    
                sh "docker container ls -a -q -f name=${env.CONTAINER_NAME_FE} | xargs --no-run-if-empty docker rm"
            }
        }
        
        // 도커 이미지 빌드
        stage("Docker Image Build") {
            steps {
                // script {  // 'script' 블록 추가
                    // try {
                        dir("${env.PROJECT_DIR_FE}") {
                            sh "docker build --no-cache -t ${env.IMAGE_NAME_FE}:${BUILD_NUMBER} ."
                        }
                    // } catch (Exception e) {
                    //     // 빌드를 중지하고 오류 상태로 설정합니다.
                    //     echo "Docker build failed: ${e.getMessage()}"
                    //     error "Stopping build due to errors"
                    // }
                // }
            }
        }

        // 컨테이너 실행
        stage("Docker Container Run") {
            steps {
                script {
                    // 최신 빌드 이미지를 사용하여 컨테이너 실행 (Rollback Stage와 구분)
                    sh "docker run -d -p 3001:3000 --name ${env.CONTAINER_NAME_FE} ${env.IMAGE_NAME_FE}:${BUILD_NUMBER}"
                }
            }
        }

        // // 롤백 스테이지 (선택적)
        // stage('Rollback on Failure') {
        //     when {
        //         // 이전 단계들 중에서 실패한 경우에만 이 스테이지 실행
        //         expression { currentBuild.currentResult == 'FAILURE' }
        //     }
        //     steps {
        //         script {
        //             // 마지막 성공한 빌드에서 artifact 다운로드
        //             def lastSuccessfulBuild = currentBuild.rawBuild.getPreviousSuccessfulBuild()

        //             if (lastSuccessfulBuild != null) {
        //                 def artifact = lastSuccessfulBuild.getArtifactManager().root().child('successful_tag.txt')
        //                 def tagInfo = artifact.readToString()  // 파일 내용 읽기

        //                 echo "Rolling back to previous stable build: ${tagInfo}..."
        //                 // 태그 정보를 사용하여 이전 버전의 이미지로 컨테이너 시작
        //                 sh "docker run -d -p 3001:3000 --name ${env.CONTAINER_NAME_FE}_rollback ${tagInfo}"
        //             } else {
        //                 echo "No successful build to rollback to!"
        //             }
        //         }
        //     }
        // }
    }

    post {
        always {
            // 모든 경우에 실행되는 후처리 작업
            echo 'This will always run'
        }
        success {
            // 빌드가 성공적으로 완료된 경우에만 실행
            script {
                // 'successful_tag.txt'라는 파일에 성공한 빌드의 태그 정보를 저장합니다.
                writeFile file: 'successful_tag.txt', text: "${env.IMAGE_NAME_FE}:${BUILD_NUMBER}"
                archiveArtifacts artifacts: 'successful_tag.txt'  // 이 파일을 Jenkins artifact로 보관합니다.
            
                // 최근 성공한 이미지 태그 목록을 유지하기 위한 로직
                def recentSuccessfulTags = []  // 성공한 태그들을 저장할 리스트
                def maxImagesToKeep = 5  // 유지할 이미지 수

                // 이전 성공 빌드들로부터 태그 정보를 가져옵니다.
                def build = currentBuild

                while (build != null && recentSuccessfulTags.size() < maxImagesToKeep) {
                    def artifact = build.getArtifactManager().root().child('successful_tag.txt')

                    if (artifact.exists()) {
                        def tagInfo = artifact.readToString()
                        recentSuccessfulTags.add(tagInfo)
                    }

                    build = build.getPreviousSuccessfulBuild()
                }

                // 전체 이미지 리스트를 가져옵니다.
                def allImages = sh(script: "docker images ${env.IMAGE_NAME_FE} --format '{{.Repository}}:{{.Tag}}' ", returnStdout: true).trim().split('\n')

                // 유지할 이미지 목록에서 제외된 이미지들을 삭제합니다.
                for (image in allImages) {
                    if (!recentSuccessfulTags.contains(image)) {
                        sh "docker rmi ${image} || true"  // 삭제 중 오류가 발생해도 계속 진행합니다.
                    }
                }
            }
        }
        failure {
            // 빌드가 실패한 경우 롤백 메커니즘 실행
            script {
                // 현재 빌드가 실패한 경우 이전 성공한 빌드에서 아티팩트를 가져오기
                if (currentBuild.currentResult == 'FAILURE') {
                    echo 'Starting Rollback Process...'

                    // 이전 성공한 빌드 번호 가져오기
                    def lastSuccessfulBuildNumber = currentBuild.getPreviousSuccessfulBuild()?.number

                    if (lastSuccessfulBuildNumber != null) {
                        // "Copy Artifact" 플러그인 기능 사용
                        step([
                            $class: 'CopyArtifact',
                            projectName: "${env.JOB_NAME}", // 현재 프로젝트 이름 사용
                            filter: 'successful_tag.txt', // 가져올 파일 지정
                            target: '', // 현재 작업공간으로 파일 복사
                            fingerprintArtifacts: true, // 아티팩트 지문 생성 옵션
                            selector: specific("${lastSuccessfulBuildNumber}") // 특정 빌드 번호에서 아티팩트 선택
                        ])

                        // 파일 읽기 및 태그 정보 추출
                        def tagInfo = readFile('successful_tag.txt').trim()
                        echo "Rolling back to previous stable build: ${tagInfo}..."

                        // 이전 성공한 이미지 태그로 롤백 프로세스 수행
                        sh "docker run -d -p 3001:3000 --name ${env.CONTAINER_NAME_FE}_rollback ${tagInfo}"
                    } else {
                        echo "No successful build to rollback to!"
                    }
                }
            }
        }
    }
}